% Preamble
% ---
\documentclass[11pt]{article}

% Packages
% ---
\usepackage[utf8]{inputenc} % Unicode support (Umlauts etc.)
\usepackage[english]{babel} % Change hyphenation rules
\usepackage{hyperref} % Add a link to your document
\usepackage{graphicx} % Add pictures to your document

\usepackage{utils}

\begin{document}

\date{\today{}}
\title{Haskzure's Resource handling model}
\author{Nashwan Azhari}


\maketitle{}
\newpage

\tableofcontents{}
\newpage

%%% Start:
\section{Introduction to Azure}

\subsection{Putting the degree of complexity into perspective}

Considering there are people who have dedicated their entire careers to
mastering it, saying that Microsoft Azure is an intricate system to
use is an understatement. What goes even more without saying is how intricately
built of a system Azure is and how much effort was put into hiding its
complexities and making it as friendly as possible for administrators and
developers alike.

Regardless of implementation details per se; it was clear even from the initial
release of the old Azure Service Management API that there were indeed wholly
seperate entities providing each of the types of resources available. This kind
of separation of concerns was to be expected in the design of a public cloud
platform the scale of Azure, as it reflects the hardware elements at play in
Microsoft's datacenters. As such, it would be natural for Azure to have a
separate subsystem (a.k.a\. a \textit{Provider}) responsible for storage
offerings (as it would most likely be running on the storage nodes of the
datacenter), and another for networking (as it would most likely be running on
the high-speed switches), and yet another which offers compute resources etc\ldots

Of course, should one happen to `inherit' this layout from the underlying
hardware, he/she must make the choice of either implementing an additional API
layer to serve as the single interface to the services, or, as was out of the
question in Azure's case, expose the APIs of the subystems for the users to
interface with individually.

\subsection{The Azure Server Management API}
The Azure Service Management (ASM) API has been the canonical way of
interfacing with Azure ever since its inception. At the time, the choice was
made to design the API around a so-called `Cloud Service' entity, which
consisted of one or more instances. The remainder of the resources seemed to
to made with cloud services in mind. Storage Services are created in order to
store the disk images of the instaces, for example, as virtual networks were
used to provide a communication medium between instances even across Cloud
Services and so on\ldots

The API is based on HTTPS, with a so-called `management URL' serving as the
root of all the URIs which compose the API's facade. Azure's actions depend
on the specific path and method combination of an incoming request (for
example, it may accept a body describing a resource on a PUT/POST and
proceed with creating said resource, or respond with information on a
specific resource on a GET on some other URI). The presentation medium of
choice is schema-validated XML\@.

Cloud Services presented a trade off. On the one hand, the additional layer of
abstraction was indeed handy as it alleviated many of the major pains of
setting up remote connections (either via RDP or SSH) and similarly basic yet
tedious networking tasks required when deploying instances. However, these
benefits came at the cost of a much more rigid deployment model as opposed to
that of a design in which all resources are first-class. Thus, whilst maybe the
XML-encoded structures sent to and fro the client and ASM were more concise,
the need to adhere to a certain deployment model focused on creating and
linking lesser resources to cloud services was very restrictive.

In addition to flexibility concerns, the cloud-service-centric design meant
that performing concurrent updates within them was very hazardous. As such, the
API implementers had to make the drastic decision of avoiding to provide such
features altogether in not one or two cases throughout the facade. In fact,
concurrent handling of virtual networking resources was so hazardous that the
whole part of the API exposing this functionality had to be intentinally design
so as to force sequential use. % NOTE: link asm virtnets

In today's terms, one may best describe ASM as being a hybrid between the
`Platform as a Service' and `Infrastructure as a Service' cloud computing models
(or PaaS and IaaS, respectively). ASM's main purpose was indeed to model
interactions in an infrastructure-oriented manner, and the large resource
offering the API provides stands as tribute to this. Conversely, the heavy
gearing towards cloud services as well as the extremely pronounced efforts on
Microsoft's part to bring Azure integration to the rest of the Windows
ecosystem have been the main factors on the PaaS-e characteristics ASM beared.

\subsection{The Azure Resource Manager API}
The Azure Resource Manager (ARM) API aims to surpass the shortcomings of ASM\@.
In many respects, it is still much the same at its core: % TODO

Microsoft Azure's Resource Manager may be viewed as one of two things:

\begin{itemize}
    \item{a single API endpoint providing cloud orchestration-like capabilities.}
    \item{the union of numerous specialised APIs into a single one.}
\end{itemize}


\subsection{ARM as a cloud orchestration tool.}
Azure Resource Manager mainly serves as a single API enpoint which, provided a
JSON file (a.k.a. ARM template) describing the layout of numerous resources of
varying types, can schedule and undergo all the required API calls to the specific
resource providers that should be involved for the deployment of the template.


\subsection{ARM as a union of APIs.}


\subsection{On the Azure Resource Manager APIs}


\subsection{ARM API general Resource representation.}


\subsection{The need of a uniform resource model.}

The Resource ADT\@.
The AzureResource typeclass.


\subsection{Generating Resource properties.}


\end{document}
